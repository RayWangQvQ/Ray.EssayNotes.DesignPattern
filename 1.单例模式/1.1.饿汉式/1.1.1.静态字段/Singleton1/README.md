# 饿汉单例模式（利用静态字段）

## 1.实例化一个类的顺序
    
### 1.1.细分

* 类的成员
    + 字段（又称：成员变量）
    + 属性
    + 方法
    + 构造方法
    + 内部类
* 成员的修饰符
    + 静态成员
    + 实例成员
* 层次结构
    + 父类
    + 子类

### 1.2.没有继承关系时，实例化执行顺序

1. 静态字段
2. 静态构造方法
3. 实例字段
4. 实例构造方法

属性、方法和内部类都是在调用的时候才会被执行到，和实例化没有直接关系。

理解：

* 先公后私（先静态后实例）
* 先零件后整体（先生成字段再执行构造方法生成实例）

### 1.3.有继承关系，实例化执行顺序

1. 子类的静态字段
2. 子类的静态构造方法
3. 子类的实例字段
4. 父类的静态字段
5. 父类的静态构造方法
6. 父类的实例字段
7. 父类的实例构造方法
8. 子类的实例构造方法

也很好理解，实例化子类对象执行顺序与之前相同，但是当执行最后一步（执行实例构造方法）之前，这时候必须要先把自己的父亲实例化出来，然后再实例化自己。

而实例化父类对象的执行循序仍然与之前相同。


## 2.静态成员时什么时候被实例化的？

所有静态类或静态成员，都是再被装载（被使用）时被实例化的，并不是系统刚运行时被一股脑实例化的。

在该sample中，Single类中的静态私有字段（instance）是在Program.Main()方法里，运行到Singleton.GetInstance()时进行实例化的。

## 3.优缺点

### 3.1.优点

* 写法简单
* 避免了线程同步问题（因为是在类第一次被装载时进行实例化的）

### 3.2.缺点

* 不是lazy loading，可能造成内存浪费

因为是classloder，当从始至终都未使用这个实例时，如果有其他原因导致这个类被装载，就会造成内存浪费。

## 补充

因为类的实例化顺序，同理，也可以将创建实例对象放到静态构造函数里。